\chapter{Graph Theory}
\section{2-SAT\ \small(ct)}
	\inputminted{cpp}{GraphTheory/2_sat.cpp}
\section{割点与桥\ \small(ct)}
	\subsection*{割点}
		\inputminted{cpp}{GraphTheory/cut_point.cpp}
	\subsection*{桥}
		\inputminted{cpp}{GraphTheory/bridge.cpp}
\section{Steiner\ tree\ \small(lhy)}
	\inputminted{cpp}{GraphTheory/steiner_tree.cpp}
\section{K短路\ \small(lhy)}
	\inputminted{cpp}{GraphTheory/kth_minimum_path.cpp}
\section{最大团\ \small(Nightfall)}
	时间复杂度建议$ n \leq 150 $
	\inputminted{cpp}{GraphTheory/maximum_clique.cpp}
\section{极大团计数\ \small(Nightfall)}
	$ 0 $-based, 需删除自环
	\\极大团计数, 最坏情况$ O(3^{n / 3}) $
	\inputminted{cpp}{GraphTheory/maximum_clique_count.cpp}
\section{二分图最大匹配\ \small(lhy)}
	左侧$ n $个点，右侧$ m $个点，$ 1 $-based，初始化将$ matx $和$ maty $置为$ 0 $
	\inputminted{cpp}{GraphTheory/hopcroft_karp.cpp}
\section{一般图最大匹配\ \small(lhy)}
	\inputminted{cpp}{GraphTheory/blossom.cpp}
\section{KM算法\ \small(Nightfall)}
	$ O(n^3) $，$ 1 $-based，最大权匹配
	\\不存在的边权值开到$ -n \times (\left| MAXV \right|) $，$ \infty $为$ 3 n \times (\left| MAXV \right|) $
	\\匹配为$ (lk_i, i) $
	\inputminted{cpp}{GraphTheory/km.cpp}
\section{最小树形图\ \small(Nightfall)}
	\inputminted{cpp}{GraphTheory/zhu_liu.cpp}
\section{支配树\ \small(Nightfall,ct)}
	\subsection*{DAG\ \small(ct)}
		\inputminted{cpp}{GraphTheory/dominator_tree_dag.cpp}
	\subsection*{一般图\ \small(Nightfall)}
		\inputminted{cpp}{GraphTheory/dominator_tree.cpp}
\section{虚树\ \small(ct)}
	\inputminted{cpp}{GraphTheory/virtual_tree.cpp}
\section{点分治\ \small(ct)}
	\inputminted{cpp}{GraphTheory/divide_conquer_on_tree.cpp}
\section{树上倍增\ \small(ct)}
	\inputminted{cpp}{GraphTheory/multiplier_on_tree.cpp}
\section{Link-Cut\ Tree\ \small(ct)}
	LCT常见应用
	\begin{itemize}
		\item 动态维护边双
			\\可以通过LCT来解决一类动态边双连通分量问题。即静态的询问可以用边双连通分量来解决，而树有加边等操作的问题。
			\\把一个边双连通分量缩到LCT的一个点中，然后在LCT上求出答案。缩点的方法为加边时判断两点的连通性，如果已经联通则把两点在目前LCT路径上的点都缩成一个点。
		\item 动态维护基环森林
			\\通过LCT可以动态维护基环森林，即每个点有且仅有一个出度的图。有修改操作，即改变某个点的出边。对于每颗基环森林记录
			一个点为根，并把环上额外的一条边单独记出，剩下的边用LCT维护。一般使用有向LCT维护。
			\\修改时分以下几种情况讨论：
			\begin{itemize}[nosep]
				\item 修改的点是根，如果改的父亲在同一个连通块中，直接改额外边，否则删去额外边，在LCT上加边。
				\item 修改的点不是根，那么把这个点和其父亲的联系切除。如果该点和根在一个环上，那么把多的那条边加到LCT上。最后如果改的那个父亲和修改的点在一个联通块中，记录额外边，否则LCT上加边。
			\end{itemize}
		\item 子树询问
			\\通过记录轻边信息可以快速地维护出整颗LCT的一些值。如子树和，子树最大值等。在Access时要进行虚实边切换，这时减去实边的贡献，并加上新加虚边的贡献即可。有时需要套用数据结构，如Set来维护最值等问题。
			\\模板：
			\begin{itemize}[nosep]
				\item $ x \to y $链$ + z $
				\item $ x \to y $链变为$ z $
				\item 在以$ x $为根的树对$ y $子树的点权求和
				\item $ x \to y $链取$ \max $
				\item $ x \to y $链求和
				\item 连接$ x, y $
				\item 断开$ x, y $
			\end{itemize}
			$ V $单点值，$ sz $平衡树的size，$ mv $链上最大，$ S $链上和，$ sm $区间相同标记，$ lz $区间加标记，$ B $虚边之和，$ ST $子树信息和，$ SM $子树和链上信息和。更新时：
			\\$ S[x] = S[c[x][0]] + S[c[x][1]] + V[x] $
			\\$ ST[x] =B[x] + ST[c[x][0]] + ST[c[x][1]] $
			\\$ SM[x] = S[x] + ST[x] $
	\end{itemize}
	\inputminted{cpp}{GraphTheory/link_cut_tree.cpp}
\section{圆方树\ \small(ct)}
	\inputminted{cpp}{GraphTheory/circle_square_tree.cpp}
\section{无向图最小割\ \small(Nightfall)}
	\inputminted{cpp}{GraphTheory/stoer_wagner.cpp}
\section{最大流\ \small(lhy,ct)}
	\subsection*{Dinic\ \small(ct)}
		\inputminted{cpp}{GraphTheory/dinic.cpp}
	\subsection*{SAP\ \small(lhy)}
		\inputminted{cpp}{GraphTheory/sap.cpp}
\section{费用流\ \small(ct)}
	\subsection*{SPFA(ct)}
		\inputminted{cpp}{GraphTheory/min_cost_max_flow.cpp}
	\subsection*{zkw(lhy)}
		\inputminted{cpp}{GraphTheory/zkw_min_cost_flow.cpp}
\section{图论知识\ \small(gy,lhy)}
	\subsection*{Hall theorem}
		二分图$ G = (X, Y, E) $有完备匹配的充要条件是：对于$ X $的任意一个子集$ S $都满足$ \left| S \right| \leq \left| A(S) \right| $，$ A(S) $是$ Y $的子集，是$ S $的邻集（与$ S $有边的边集）。
	\subsection*{Prufer编码}
		树和其prufer编码一一对应, 一颗$ n $个点的树, 其prufer编码长度为$ n − 2 $, 且度数为$ d_i $的点在prufer编码中出现$ d_i − 1 $次。
		\\由树得到序列: 总共需要$ n − 2 $步, 第$ i $步在当前的树中寻找具有最小标号的叶子节点，将与其相连的点的标号设为Prufer序列的第$ i $个元素$ p_i $, 并将此叶子节点从树中删除, 直到最后得到一个长度为$ n − 2 $的Prufer序列和一个只有两个节点的树。
		\\由序列得到树: 先将所有点的度赋初值为$ 1 $, 然后加上它的编号在Prufer序列中出现的次数, 得到每个点的度; 执行$ n − 2 $步, 第$ i $步选取具有最小标号的度为$ 1 $的点$ u $与$ v = p_i$相连, 得到树中的一条边, 并将$ u $和$ v $的度减$ 1 $。最后再把剩下的两个度为$ 1 $的点连边, 加入到树中。
		\\相关结论:
		\begin{itemize}[nosep]
			\item $ n $个点完全图, 每个点度数依次为$ d_1, d_2 , \dots, dn $，这样生成树的棵树为：$ \frac{(n - 2) !}{(d_1 - 1)! (d_2 - 1)! \dots (d_n - 1)!} $
			\item 左边有$ n_1 $个点, 右边有$ n_2 $个点的完全二分图的生成树棵树为：$ n_1^{n_2 - 1} + n_2^{n_1 - 1} $
			\item $ m $个连通块, 每个连通块有$ c_i $个点, 把他们全部连通的生成树方案数：$ (\sum c_i)^{m - 2} \prod c_i $
		\end{itemize}
	\subsection*{差分约束}
		若要使得所有量两两的值最接近, 则将如果将源点到各点的距离初始化为$ 0 $。若要使得某一变量与其余变量的差最大, 则将源点到各点的距离初始化为$ \infty $, 其中之一为$ 0 $。 若求最小方案则跑最长路, 否则跑最短路。
	\subsection*{弦图}
		弦图：任意点数$ \geq 4 $的环皆有弦的无向图
		\\单纯点：与其相邻的点的诱导子图为完全图的点
		\\完美消除序列：每次选择一个单纯点删去的序列
		\\弦图必有完美消除序列
		\\$ O(m + n) $求弦图的完美消除序列：每次选择未选择的标号最大的点，并将与其相连的点标号$ + 1 $，得到完美消除序列的反序
		\\最大团数$ = $最小染色数：按完美消除序列从后往前贪心地染色
		\\最小团覆盖$ = $最大点独立集：按完美消除序列从前往后贪心地选点加入点独立集
	\subsection*{计数问题}
		\begin{itemize}
			\item \textbf{有根树计数}
				\\$ a_1 = 1 $
				\\$ a_{n + 1} = \frac{\sum\limits_{j = 1}^{n} j \cdot a_j \cdot S_{n, j}}{n} $
				\\$ S_{n, j} = \sum\limits_{i = 1}^{n / j} a_{n + 1 - ij} = S_{n - j, j} + a_{n + 1 - j} $
			\item \textbf{无根树计数}
				\\$ \begin{cases}
					a_n - \sum\limits_{i = 1}^{n / 2} a_i a_{n - i} & n \text{ is odd}\\
					a_n - \sum\limits_{i = 1}^{n / 2} a_i a_{n - i} + \frac{1}{2} a_{\frac{n}{2}} (a_{\frac{n}{2}} + 1) & n \text{ is even}
				\end{cases} $
			\item \textbf{生成树计数}
				\\Kirchhoff Matrix $ T = Deg − A $, $ Deg $是度数对角阵, $ A $是邻接矩阵。无向图度数矩阵是每个点度数; 有向图度数矩阵是每个点入度。邻接矩阵$ A[u][v] $表示$ u \to v $边个数, 重边按照边数计算, 自环不计入度数。
				\\无向图生成树计数: $ c = \left|K\text{的任意}1\text{个}n−1\text{阶主子式}\right| $
				\\有向图外向树计数: $ c = \left|\text{去掉根所在的那阶得到的主子式}\right| $
			\item \textbf{Edmonds Matrix}
				\\Edmonds matrix $ A $ of a balanced ($ \left| U \right| = \left| V \right| $) bipartite graph $ G = (U, V, E) $：
				\\$ A_{ij} = \begin{cases}
					x_{ij} & (u_i, v_j) \in E\\
					0 & (u_i, v_j) \notin E
				\end{cases} $
				\\where the $ x_{ij} $ are indeterminates.
				\\$ G $有完备匹配当且仅当关于$ x_{ij} $的多项式$ \det(A_{ij}) $不恒为$ 0 $。
				\\完备匹配的个数等于多项式中单项式的个数
			\item \textbf{偶数点完全图完备匹配计数}
				\\$ (n - 1)!! $
			\item \textbf{无根二叉树计数}
				\\$ (2n - 5)!! $
			\item \textbf{有根二叉树计数}
				\\$ (2n - 3)!! $
		\end{itemize}
	\subsection*{上下界网络流}
		$ B(u, v) $表示边$ (u, v) $流量的下界，$ C(u, v) $表示边$ (u, v) $流量的上界，设$ F(u, v) $表示边$ (u, v) $的实际流量\\
		设$ G(u, v) = F(u, v) - B(u, v) $，则$ 0 \leq G(u, v) \leq C(u, v) - B(u, v) $
		\begin{itemize}
			\item 无源汇的上下界可行流
				\\建立超级源点$ S^\ast $和超级汇点$ T^\ast $，对于原图每一条边$ (u, v) $在新网络中连如下三条边：$ S^\ast \to v $，容量为$ B(u, v) $；$ u \to T^\ast $，容量为$ B(u, v) $；$ u \to v $，容量为$ C(u, v) - B(u, v) $。最后求新网络的最大流，判断从超级源点$ S^\ast $出发的边是否都满流即可，边$ (u, v) $的最终解中的实际流量为$ G(u, v) + B(u, v) $。
			\item 有源汇的上下界可行流
				\\从汇点$ T $到源点$ S $连一条上界为$ \infty $，下界为$ 0 $的边。按照无源汇的上下界可行流一样做即可，流量即为$ T \to S $边上的流量。
			\item 有源汇的上下界最大流
				\begin{itemize}
					\item 在有源汇的上下界可行流中，从汇点$ T $到源点$ S $的边改为连一条上界为$ \infty $，下界为$ x $的边。$ x $满足二分性质，找到最大的$ x $使得新网络存在有源汇的上下界可行流即为原图的最大流。
					\item 从汇点$ T $到源点$ S $连一条上界为$ \infty $，下界为$ 0 $的边，变成无源汇的网络。按照无源汇的上下界可行流的方法，建立超级源点$ S^\ast $与超级汇点$ T^\ast $，求一遍$ S^\ast \to T^\ast $的最大流，再将从汇点$ T $到源点$ S $的这条边拆掉，求一次$ S \to T $的最大流即可。
				\end{itemize}
			\item 有源汇的上下界最小流
				\begin{itemize}
					\item 在有源汇的上下界可行流中，从汇点$ T $到源点$ S $的边改为连一条上界为$ x $，下界为$ 0 $的边。$ x $满足二分性质，找到最小的$ x $使得新网络存在有源汇的上下界可行流即为原图的最大流。
					\item 按照无源汇的上下界可行流的方法，建立超级源点$ S^\ast $与超级汇点$ T^\ast $，求一遍$ S^\ast \to T^\ast $的最大流，但是注意不加上汇点$ T $到源点$ S $的这条边，即不使之改为无源汇的网络去求解。求完后，再加上那条汇点$ T $到源点$ S $的边，上界为$ \infty $的边。因为这条边的下界为$ 0 $，所以$ S^\ast $, $ T^\ast $无影响，再求一次$ S^\ast \to T^\ast $的最大流。若超级源点$ S^\ast $出发的边全部满流，则$ T \to S $边上的流量即为原图的最小流，否则无解。
				\end{itemize}
			\item 上下界费用流
				\\求无源汇上下界最小费用可行流或有源汇上下界最小费用最大可行流，用相应构图方法，给边加上费用即可。
				\\求有源汇上下界最小费用最小可行流，先按相应构图方法建图，求出一个保证必要边满流情况下的最小费用。如果费用全部非负，那么此时的费用即为答案。如果费用有负数，继续做从$ S $到$ T $的流量任意的最小费用流，加上原来的费用就是答案。
		\end{itemize}
	\subsection*{费用流消负环}
		新建超级源$ S^\ast $和超级汇$ T^\ast $，对于所有流量非空的负权边$ e $，先满流($ ans $+=$ e.f $*$ e.c $, $  e.rev.f $+=$ e.f $, $ e.f $=$ 0 $)，再连边$ S^\ast \to e.to $，$ e.from \to T\ast $，流量均为$ e.f (> 0) $，费用均为$ 0 $。再连边$ T \to S $，流量为$ \infty $，费用为$ 0 $。跑一遍$ S^\ast \to T^\ast $的最小费用最大流，将费用累加$ ans $，拆掉$ T \to S $那条边（此边的流量为残量网络中$ S \to T $的流量。此时负环已消，再继续跑最小费用最大流。
	\subsection*{二物流}
		水源$ S_1 $，水汇$ T_1 $，油源$ S_2 $，油汇$ T_2 $，每根管道流量共用，使流量和最大。
		\\建超级源$ S_1^\ast $，超级汇$ T_1^\ast $，连边$ S_1^\ast \to S_1 $，$ S_1^\ast \to S_2 $，$ T_1 \to T_1^\ast $，$ T_2 \to T_1^\ast $，设最大流为$ x_1 $。
		\\建超级源$ S_2^\ast $，超级汇$ T_2^\ast $，连边$ S_2^\ast \to S_1 $，$ S_2^\ast \to T_2 $，$ T_1 \to T_2^\ast $，$ S_2 \to T_2^\ast $，设最大流为$ x_2 $。
		则最大流中水流量$ \frac{x_1 + x_2}{2} $，油流量$ \frac{x_1 - x_2}{2} $。
	\subsection*{最大权闭合子图}
		给定一个带点权的有向图，求其最大权闭合子图。
		\\从源点$ S $向每一条正权点连一条容量为权值的边，每个负权点向汇点$ T $连一条容量为权值绝对值的边，有向图原来的边容量为$ \infty $。求它的最小割，与源点$ S $连通的点构成最大权闭合子图，权值为\textit{正权值和}$ - $\textit{最小割}。
	\subsection*{最大密度子图}
		给定一个无向图，求其一个子图，使得子图的边数$ \left| E \right| $和点数$ \left| V \right| $满足$ \frac{\left| E \right|}{\left| V \right|} $最大。
		\\二分答案$ k $，使得$ \left| E \right| - k \left| V \right| \geq 0 $有解，将原图边和点都看作点，边$ (u, v) $分别向$ u $和$ v $连边求最大权闭合子图。
		
