\chapter{Data Structure}
\section{莫队\ \small(ct)}
	\inputminted{cpp}{DataStructure/mo_dui.cpp}
\section{ST表\ \small(ct)}
	\inputminted{cpp}{DataStructure/st_table.cpp}
\section{带权并查集\ \small(ct)}
	\inputminted{cpp}{DataStructure/union_find_weighted.cpp}
\section{可并堆\ \small(ct)}
	\inputminted{cpp}{DataStructure/mergeable_heap.cpp}
\section{线段树\ \small(ct)}
	\subsection*{zkw线段树}
		$ 0 $-based
		\inputminted{cpp}{DataStructure/zkw_segment_tree.cpp}
	\subsection*{李超线段树}
		\inputminted{cpp}{DataStructure/li_chao_segment_tree.cpp}
	\subsection*{吉利线段树}
		吉利线段树能解决一类区间与某个数取最大或最小，区间求和的问题。以区间取最小值为例，在线段树的每一个节点额外维护区间中的最大值$ ma $，严格次大值$ se $以及最大值个树$ t $。现在假设我们要让区间$ \lbrack L, R \rbrack $对$ x $取最小值，先在线段树中定位若干个节点，对于每个节点分三种情况讨论：
		\begin{itemize}[nosep]
			\item 当$ ma \leq x $时，显然这一次修改不会对这个节点产生影响，直接推出。
			\item 当$ se < x < ma $时，显然这一次修改只会影响到所有最大值，所以把$ num $加上$ t \times (x - ma) $，把$ ma $更新为$ x $，打上标记推出。
			\item 当$ x \leq se $时，无法直接更新这一个节点的信息，对当前节点的左儿子和右儿子递归处理。
		\end{itemize}
		单次操作的均摊复杂度为$ O(\log^2 n) $
	\subsection*{线段树维护折线}
		对于线段树每个结点维护两个值：$ ans $和$ max $，$ ans $表示只考虑这个区间的可视区间的答案，$ max $表示这个区间的最大值。那么问题的关键就在于如何合并两个区间，显然左区间的答案肯定可以作为总区间的答案，那么接下来就是看右区间有多少个在新加入左区间的约束后是可行的。考虑如果右区间最大值都小于等于左区间最大值那么右区间就没有贡献了，相当于是被整个挡住了。
		\\如果大于最大值，就再考虑右区间的两个子区间：左子区间、右子区间，加入左子区间的最大值小于等于左区间最大值，那么就递归处理右子区间；否则就递归处理左子区间，然后加上右子区间原本的答案。考虑这样做的必然性：因为加入左区间最高的比左子区间最高的矮，那么相当于是左区间对于右子区间没有约束，都是左子区间产生的约束。但是右子区间的答案要用右区间答案$ - $左子区间答案，不能直接调用右子区间本身答案，因为其本身答案没有考虑左子区间的约束。
	\subsection*{线段树维护矩形面积并}
		线段树上维护两个值：$ Cover $和$ Len $
		\\$ Cover $意为这个区间被覆盖了多少次
		\\$ Len $意为区间被覆盖的总长度
		\\Maintain的时候，如果$ Cover > 0 $，$ Len $直接为区间长
		\\否则从左右子树递推$ Len $
		\\修改的时候直接改$ Cover $就好
\section{二进制分组\ \small(ct)}
	用线段树维护时间的操作序列，每次操作一个一个往线段树里面插，等到一个线段被插满的时候用归并来维护区间的信息。查询的时候如果一个线段没有被插满就递归下去。定位到一个区间的时候在区间里面归并出来的信息二分。
	\inputminted{cpp}{DataStructure/binary_group.cpp}
\section{Splay\ \small(ct)}
	\subsection*{指针版}
		\inputminted{cpp}{DataStructure/splay.cpp}
	\subsection*{维修序列}
		\inputminted{cpp}{DataStructure/splay_arr.cpp}
\section{Treap\ \small(ct)}
	\inputminted{cpp}{DataStructure/treap.cpp}
\section{可持久化平衡树\ \small(ct)}
	\inputminted{cpp}{DataStructure/functional_treap.cpp}
\section{CDQ分治\ \small(ct)}
	\inputminted{cpp}{DataStructure/cdq_divide.cpp}
\section{Bitset\ \small(ct)}
	\inputminted{cpp}{DataStructure/bitset.cpp}
\section{斜率优化\ \small(ct)}
	对于斜截式$ y = k x + b $，如果把$ k_i $看成斜率，那dp时需要最小化截距，把斜截式转化为$ b_i = - k_i x_j + y_j $，就可以把可以转移到这个状态的点看作是二维平面上的点$ (- x_j, y_j) $，问题转化为了在平面上找一个点使得斜率为$ k_i $的直线的截距最小。这样的点一定在凸包上，这样的点在凸包上和前一个点的斜率$ \leq k_i$，和后面一个点的斜率$ \geq k_i $。这样就可以在凸包上二分来加速转移。当点的横坐标$ x_i $和斜率$ k_i $都是单调的，还可以用单调队列来维护凸包。
	\subsection*{单调队列}
		\inputminted{cpp}{DataStructure/slope_optimize_queue.cpp}
	\subsection*{线段树}
		\inputminted{cpp}{DataStructure/slope_optimize_segment.cpp}
\section{树分块\ \small(ct)}
	树分块套分块：给定一棵有点权的树，每次询问链上不同点权个数
	\inputminted{cpp}{DataStructure/tree_block.cpp}
\section{KD\ tree\ \small(lhy)}
	\inputminted{cpp}{DataStructure/kd_tree.cpp}
\section{DLX\ \small(Nightfall)}
	\inputminted{cpp}{DataStructure/dlx.cpp}